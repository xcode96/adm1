<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title>Mani Bharathi</title>
  <meta content="" name="description">
  <meta content="" name="keywords">

  <!-- Favicons -->
  <link href="img/favicon.png" rel="icon">
  <link href="img/apple-touch-icon.png" rel="apple-touch-icon">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="vendor/aos/aos.css" rel="stylesheet">
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="vendor/swiper/swiper-bundle.min.css" rel="stylesheet">

  <!-- Template Main CSS File -->
  <link href="css/style.css" rel="stylesheet">
</head>

<body>

  <!-- ======= Mobile nav toggle button ======= -->
  <i class="bi bi-list mobile-nav-toggle d-xl-none"></i>

  <!-- ======= Header ======= -->
 <header id="header">
    <div class="d-flex flex-column">

      <div class="profile">
      
        <h1 class="text-light"><a href="index-2.html">

          <br>ЖĆØĐ€96</a>
        </a></h1>
        <div class="social-links mt-3 text-center">
        </div>
      </div>

      <nav id="navbar" class="nav-menu navbar">
        <ul>
          <li><a href="index-2.html"   class="nav-link scrollto active"><i class="bi bi-house navicon"></i>Home</a></li>
          <li><a href="resume.html"  class="nav-link scrollto"><i class="bi bi-file-earmark-text navicon"></i>Resume</a></li>
          <li><a href="portfolio.html" class="nav-link scrollto"><i class="bi bi-images navicon navicon"></i><span>Portfolio</span></a></li>
          <li><a href="cheatsheets.html" class="nav-link scrollto"><i class="bi bi-shield-check"></i>Cheatsheets</a></li>
          <li><a href="Resourses.html" class="nav-link scrollto"><i class="bi bi-router"></i>Start Resources</a></li>
          <li><a href="https://buymeacoffee.com/xcode96" target="_blank" class="nav-link scrollto"><i class="bi bi-heart navicon"></i>Buy Me a Coffee</a></li> 

  
            </ul>
          </li>
        </ul>
      </nav><!-- .nav-menu -->
    </div>
  </header><!-- End Header -->

  <main id="main">
    <!-- ======= Breadcrumbs ======= -->
    <section id="breadcrumbs" class="breadcrumbs">
      <div class="container">

        <div class="d-flex justify-content-between align-items-center">
          <h2>Malware Analysis</h2>
          <ol>
            <li><a href="index.html">Home</a></li>
            <li>Malware Analysis</li>
          </ol>
        </div>

      </div>
    </section><!-- End Breadcrumbs -->

    <!-- ======= Cheatsheet Section ======= -->
    <section id="cheatsheet" class="cheatsheet">
      <div class="container">

        <div class="row gy-4">
          <div class="col-lg-12">
            <!-- ======= Disclaimer Alert ======= -->
            <div class="alert alert-warning alert-dismissible fade show" role="alert" data-aos="fade-right">
              <strong>Disclaimer:</strong> These notes are my personal summaries and interpretations of various online
              courses. They are not direct transcriptions and reflect my own understanding.
              <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
            <div class="cheatsheet-content">
              <h2 id="1-manual-malware-analysis">1. Manual Malware Analysis</h2>

              <h3 id="12-static-analysis">1.2 Static Analysis</h3>
              <p>We are usually searching for:</p>
              <ul>
                <li>How it works.</li>
                <li>How to identify it.</li>
                <li>How to defeat it or eliminate it.</li>
                <li>This also includes finding Indicators of Compromise (IoC); we want to look for network or
                  host-based indicators, including:</li>
                <ul>
                  <li>Anything unique about a file like hash, size, names.</li>
                  <li>Binary characteristics: strings, PDB paths.</li>
                  <li>Changes made to the OS.</li>
                </ul>
              </ul>

              <h4 id="111-host-based-indicators">1.1.1 Host-Based Indicators</h4>
              <p>
                Malware usually wants to persist on the system, whether by changing the registry keys or downloading
                something else. Filenames and Paths can be good host-based indicators. Something like %APPDATA% is a
                Windows path variable; a good indicator is something unique, if it is something present in a lot of
                samples then it's not a good indicator. Malware usually uses registry keys, especially to make
                persistence and make the program always run when the computer is booted.
              </p>
              <p>
                <code>HKEY_CURRENT_USER/Microsoft/Windows/Currentversion/Run</code> and
                <code>HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services</code> are very often used to establish
                persistence keys. Mutexes are used to lock resources from the computer so the malware does not
                interfere with itself.
              </p>

              <h4 id="112-network-based-indicators">1.1.2 Network-Based Indicators</h4>
              <p>
                The main thing here is the C2 server where the malware is probably connecting to, usually: IPs,
                protocols and ports, HTTP headers (cookies or user-agents), or even some signatures. It is important
                to be able to distinguish the URL parts (scheme, domain, path, and query). The user-agent usually
                gives us enough info, like browser type, version, OS, and architecture.
              </p>

              <h4 id="113-basic-analysis">1.1.3 Basic Analysis</h4>
              <p>We need to extract things without executing it:</p>
              <ul>
                <li>
                  <strong>Hashing:</strong> This is very good because the smallest change will change the bits of the
                  program, the core of a hash algorithm is extremely difficult, the most secure one today is SHA-256,
                  but there is also SHA-128 and MD5, there are many hashing tools.
                </li>
                <li>
                  <strong>Strings:</strong> When we compile the program, the hard-burn strings will survive and be
                  compiled as well. From here, we could find filenames, registry paths or keys, HTTP user-agents, PBD
                  Strings. This can also be shown in HEX ASCII format. Usually, C-Convention languages end lines with
                  <code>0x00</code>. If we use UNICODE, the convention is different because Microsoft standard is
                  UTF-16 because each character is two bytes; this uses little-endian, so
                  <code>0x0048 == 48 00</code>. One of the main tools is strings, which is available for both Windows
                  and Linux. We need to distinguish between compiler strings and real important strings.
                </li>
                <li>
                  <strong>Encoding:</strong> Is converting the shape of the data. Malware can be encrypted,
                  obfuscated, or encoded; they are usually hexadecimal, XOR, or Base64.
                  <ul>
                    <li><strong>Hexadecimal:</strong> This is useful to get data in readable format.</li>
                    <li>
                      <strong>Base64:</strong> Data is represented using 64 printable characters, character '=' or
                      '==' is usually used to make the chunks match the 3 chunks used so they can be decoded.
                      JavaScript and PowerShell usually use this; CyberChef can be used to decode this.
                    </li>
                    <li>
                      <strong>XOR:</strong> Is a binary operation, so here what we do is modify the data. The table is
                      basically "every place the bits disagree is a 1"; this can also be thought of as Addition mod 2
                      (<code>1+1 % 2</code>). So here we use a key to encode and decode data; some properties are:
                      <code>(X^00=X; X^X=00)</code>.
                    </li>
                    <li>
                      <strong>Tools:</strong>
                      <ul>
                        <li>CyberChef</li>
                        <li>Floss (Flare Obfuscated String Solver): allows us to get the strings that strings don't
                          get.</li>
                        <li>010 Editor: view and edit raw hex/ASCII.</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li>
                  <strong>Open-Source Intelligence:</strong> We should be careful and do not upload malware samples to
                  VT since threat actors can know what malware we have; instead always use MD5 or hashes. Google is
                  also a very good source, using Google Dorks we can find important info about source code, unique
                  strings, hashes, and malware families. Use this with care because this can be very misleading.
                </li>
                <li>
                  <strong>PE File Format:</strong> Portable Executable Format is the standard Windows executable.
                  Windows have made the program backwards compatible; we have:
                  <ul>
                    <li>
                      <strong>.exe:</strong> An executable program that once executed it becomes its own process, with
                      its own chunk of separated memory. Most malware runs in user mode, not kernel mode. They have:
                      <ul>
                        <li><strong>Headers:</strong> Tells the OS how to deal with this file, like where is the entry
                          point, what DLL dependencies are needed, how the sections should be arranged in the memory
                          (section headers), and how the functionality of this app is exposed to other apps (exports).
                          We have the DOS Header and the Rich Header that is automatically added by the compiler.</li>
                        <li>Sections</li>
                      </ul>
                    </li>
                    <li><strong>.dll:</strong> Dynamic link library, provides facilities that can be used by other
                      programs; they can be loaded and unloaded; these offer malware much flexibility to deploy
                      malware. Three types of linking: static (the file has the dependencies), load-time, and
                      run-time.</li>
                    <li><strong>.sys:</strong> Kernel drivers that executed outside of the OS.</li>
                  </ul>
                </li>
                <li>
                  <strong>Packing:</strong> It is mainly used for malware to avoid static malware analysis; one of the
                  ways to identify something is packed is if we use strings and get nothing or get encrypted stuff.
                  Tools are: PEiD, DIE (one of the best ones), CFF Explorer.
                </li>
                <li>
                  <strong>Unpacking:</strong> Take the code and get it; the tools can be: CFF Explorer, upx command
                  line tool, capa (it disassembles the code and makes an automatic analysis).
                </li>
              </ul>

              <h3 id="12-dynamic-analysis">1.2 Dynamic Analysis</h3>

              <h4 id="121-malware-sandboxes">1.2.1 Malware Sandboxes</h4>
              <p>
                We take the malware and execute it in an environment that simulates the necessary; like Joe Sandbox,
                Cuckoo, VMRay, Hybrid Analysis; however, this only captures a subset of the available code paths, and
                usually, some malware detects when they are running in a sandbox; and we cannot support all types of
                files as well as not having the complete picture of what is happening. So we can then create our own
                environment to run the malware, like FlareVM.
              </p>

              <h4 id="122-control-environment">1.2.2 Control Environment</h4>
              <ul>
                <li>Disable shared folders, if we really need them then set them to read-only.</li>
                <li>The network adapters are set to Host-Only.</li>
                <li>Disable any Unity integration features.</li>
                <li>Reset the VM to a clean snapshot of before analyzing the file or executing it again.</li>
              </ul>

              <h4 id="123-tips">1.2.3 Tips</h4>
              <ul>
                <li>Avoid storing raw malware on the host.</li>
                <li>Use password compression to store the malware as a zip file.</li>
                <li>Avoid having the .exe extension in the name of the malware.</li>
              </ul>

              <h4 id="124-tools">1.2.4 Tools</h4>
              <ul>
                <li>
                  <strong>System Internal Monitoring:</strong>
                  <ul>
                    <li><strong>Process Explorer (procexp.exe):</strong> versatile task manager, allows us to see the
                      strings on memory.</li>
                    <li><strong>Process Monitor (procmon.exe):</strong> monitors file systems, process, and some
                      network events in real-time; we can set filters to manage the output and not see the noise data.
                      Good filters are: ProcessCreate, WriteFile, RegSetValue, and SetDispositionInformationFile; we
                      can even set a custom set of filters to have on hand.</li>
                  </ul>
                </li>
                <li>
                  <strong>Network Monitoring:</strong>
                  <ul>
                    <li><strong>FakeNet-NG:</strong> simulates protocol services, process handling, and filtering, it
                      can be very configurable; and also generates a .pcap file of the traffic captured.</li>
                    <li>Wireshark</li>
                  </ul>
                </li>
              </ul>

              <h4 id="125-launching-binaries">1.2.5 Launching Binaries</h4>
              <ul>
                <li>
                  <strong>EXEs:</strong> We would like to execute in an admin command prompt to allow it to do
                  everything it wants, and also allow us to see any information that may print to the console of
                  debugging messages.
                </li>
                <li>
                  <strong>DLLs:</strong> This is shared code and is going to load and then execute, but as we cannot
                  execute we can force the execution with
                  <code>rundll32.exe &lt;DLL_Name&gt;[, &lt;DLL_Export&gt;]</code>.
                </li>
                <li>Service DLL: FlareVM does not have built-in tools to avoid the malware VM detection techniques.
                </li>
              </ul>

              <h4 id="126-dumping-memory">1.2.6 Dumping Memory</h4>
              <p>
                Let the malware do the work (unpack the code or decode the strings) and then we will dump the data
                from the memory. We can use: Process Dump, that will take a process in memory and dump it to the disk
                so we can do static analysis; we can run a packed sample, suspend the process, dump the memory, and
                analyze the unpacked sample. The usage of this tool is:
                <code>&lt;pd32.exe | pd64.exe&gt; -pid &lt;pid&gt;</code> or
                <code>&lt;pd32.exe | pd64.exe&gt; -p &lt;process name&gt;</code>.
              </p>
              <p>
                Some advanced tricks:
              <ul>
                <li>Dump the process as it exists (program that exists immediately): <code>pd64.exe -closemon</code>.
                </li>
                <li>Dump any unrecognized module:
                  <ul>
                    <li><code>pd64.exe -db genquick:</code> generates a whitelist of modules running.</li>
                    <li><code>pd64.exe -system:</code> dump all modules not matching the generated whitelist from the
                      previous step.</li>
                  </ul>
                </li>
              </ul>
              </p>

              <h3 id="13-windows-managment-technologies">1.3 Windows Management Technologies</h3>

              <h4 id="131-net-framework">1.3.1 .NET Framework</h4>
              <p>
                Common Language Runtime is what allows the C# code to run in multiple systems. Some of the static tools
                we can use are: CFF Explorer, dnSpy (most important), de4dot, P/Invoke and Reflection. The framework has
                two main components: execution engine and large class library. The Common Language Infrastructure (CLI)
                is the library of way too many code already written that can be used by malware developers, this is one
                of the main reasons for attackers to use C#. These programs have metadata that we can see in the CFF
                Explorer.
              </p>

              <p>
                Now here we have the MetaData Streams, in which we can find User Strings that are the strings defined by
                the programmer. Also we have the Strings that are related to compilation and method names but not the
                user defined strings. We also have the .NET Header which has an entry point token which is where the
                code starts, the first method to be executed. Also the Metadata Tokens that contains information about
                the code functions; usually attackers know about this so they try to obfuscate the code and else.
              </p>

              <p>
                DnSpy is capable of taking the code and reversing it back to source code; it is a debugger, decompiler
                and disassembler. We can set breakpoints, single step, inspect and modify variables and set raw values.
                It can be very helpful; this tool is open-source.
              </p>

              <p>
                Obfuscation of these malware is very common so we can use tools like de4dot; it can do things like
                member renaming, string decryption, control flow deobfuscation, and dead code removal. It takes the
                encrypted part, decrypts it and then puts it back in the code to analyze replacing the obfuscated parts.
                The usage of de4dot is:
                <code>de4dot.exe &lt;programName&gt; -o &lt;outputFileName&gt; --strtyp &lt;optionalIndicatedDecryptorType&gt; delegate --strtok &lt;optionalTokenMethodFound&gt;</code>.
              </p>

              <h4 id="132-in-memory-loading">1.3.2 In-Memory Loading</h4>
              <p>
                Allows a code to load libraries and modules during runtime and not at compilation; this is one reason
                why C# is used for malware development.
              </p>

              <h4 id="133-windows-management-instrumentation">1.3.3 Windows Management Instrumentation</h4>
              <p>
                It is used for local and remote system administration; the problem is that it is very easy from C# to
                access these functions. This has many different acronyms so we must be careful not to overlook it. Since
                this is something very big we can find info in the Windows Developer Help Pages online. WMI supports
                some type of query language similar to SQL which is WQL.
              </p>

              <h4 id="134-powershell">1.3.4 PowerShell</h4>
              <p>
                We can use <code>powershell_ise.exe</code> as a tool to debug and work with obfuscated scripts from
                Windows. As execution policy we have: Unrestricted, Restricted, and AllSigned; PowerShell is capable of
                bypassing execution policies and it is very powerful. These scripts can also be downloaded and run
                without putting them in memory. By using '|' we can use the output of one command and send them to a
                following command. It is more like a programming language than an interpreter because we can do much
                more like programming languages like defining variables, using functions as objects, passing parameters
                and much more.
              </p>
              <p>
                PowerShell and .Net work very well together since PowerShell makes a lot of steps in order to always
                find modules, libraries and codes that we are trying to implement from .NET. There are many ways to
                download and execute malware from PowerShell, it can even be done with one code line.
              </p>

              <h3 id="14-advanced-static-analysis">1.4 Advanced Static Analysis</h3>

              <p>We have different levels of analysis and this part is mainly made in C/C++. Decompilators are very good
                because they get us halfway to the source code and not only in the assembly code, but usually make some
                mistakes from time to time.</p>

              <h4 id="141-ghidra">1.4.1 GHIDRA</h4>
              <p>
                GHIDRA is both a decompiler and disassembler; this is an open-source app, an alternative is IDA but this
                is a paid application. Two clues of a main function are that it is the last function before an exit
                point and that before a main function the three main parameters are pushed (<code>argc</code>,
                <code>argv**</code>). One of the most important things that we could and should do with GHIDRA is rename
                parts of the code, like when we found the main then we should rename it as "main". Another thing we can
                do is that when we find something interesting we can see where it is referenced in the code. We also do
                operations on the data that is shown from memory and much more. As soon as we find what something does
                or what something is, rename it. We can also try to find matches for registry keys (using 'e').
              </p>

              <h4 id="142-api-analysis">1.4.2 API Analysis</h4>
              <p>This API is not from the network but the API from the OS that makes special system calls, like writing
                a file.</p>

              <h4 id="143-network-analysis">1.4.3 Network Analysis</h4>
              <p>
                <code>ws2_32.dll</code> is the Windows Sockets which is the basics of networking;
                <code>wininet.dll</code> is for networking at a higher level by handling HTTP requests and responses and
                else.
              </p>
            </div>
          </div>
        </div>

      </div>
    </section><!-- End Cheatsheet Section -->

  </main><!-- End #main -->

  <!-- ======= Index ======= -->
  <div class="index-btn" onclick="toggleIndex()">Index</div>
  <div id="index" class="index">
    <div class="container mt-3">
      <div class="input-group mb-3">
        <input type="text" id="search-input" class="form-control" placeholder="Search sections..." aria-label="Search sections" aria-describedby="search-button">
        <button class="btn btn-primary" type="button" id="search-button">
          <i class="bi bi-search"></i>
        </button>
      </div>
    </div>
    <button class="expand-collapse-btn" onclick="toggleAll()">Show/Hide All</button>
    <button class="dropdown-btn">1. Manual Malware Analysis
      <i class="bi bi-caret-down-fill"></i>
    </button>
    <div class="dropdown-container">
      <div class="nested-dropdown">
        <button class="nested-dropdown-btn">1.1 Static Analysis
          <i class="bi bi-caret-down-fill"></i>
        </button>
        <div class="nested-dropdown-container">
          <a href="index.htm#111-host-based-indicators">1.1.1 Host-Based Indicators</a>
          <a href="index.htm#112-network-based-indicators">1.1.2 Network-Based Indicators</a>
          <a href="index.htm#113-basic-analysis">1.1.3 Basic Analysis</a>
        </div>
      </div>
      <div class="nested-dropdown">
        <button class="nested-dropdown-btn">1.2 Dynamic Analysis
          <i class="bi bi-caret-down-fill"></i>
        </button>
        <div class="nested-dropdown-container">
          <a href="index.htm#121-malware-sandboxes">1.2.1 Malware Sandboxes</a>
          <a href="index.htm#122-control-environment">1.2.2 Control Environment</a>
          <a href="index.htm#123-tips">1.2.3 Tips</a>
          <a href="index.htm#124-tools">1.2.4 Tools</a>
          <a href="index.htm#125-launching-binaries">1.2.5 Launching Binaries</a>
          <a href="index.htm#126-dumping-memory">1.2.6 Dumping Memory</a>
        </div>
      </div>
      <div class="nested-dropdown">
        <button class="nested-dropdown-btn">1.3 Windows Management Technologies
          <i class="bi bi-caret-down-fill"></i>
        </button>
        <div class="nested-dropdown-container">
          <a href="index.htm#131-net-framework">1.3.1 .NET Framework</a>
          <a href="index.htm#132-in-memory-loading">1.3.2 In-Memory Loading</a>
          <a href="index.htm#133-windows-management-instrumentation">1.3.3 Windows Management Instrumentation</a>
          <a href="index.htm#134-powershell">1.3.4 PowerShell</a>
        </div>
      </div>
      <div class="nested-dropdown">
        <button class="nested-dropdown-btn">1.4 Advanced Static Analysis
          <i class="bi bi-caret-down-fill"></i>
        </button>
        <div class="nested-dropdown-container">
          <a href="index.htm#141-ghidra">1.4.1 GHIDRA</a>
          <a href="index.htm#142-api-analysis">1.4.2 API Analysis</a>
          <a href="index.htm#143-network-analysis">1.4.3 Network Analysis</a>
        </div>
      </div>
    </div>
  </div>
  <!-- End Index -->

  

  <a href="index.htm#" class="back-to-top d-flex align-items-center justify-content-center"><i
      class="bi bi-arrow-up-short"></i></a>

  <!-- Vendor JS Files -->
  <script src="vendor/purecounter/purecounter.js"></script>
  <script src="vendor/aos/aos.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="vendor/glightbox/js/glightbox.min.js"></script>
  <script src="vendor/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="vendor/swiper/swiper-bundle.min.js"></script>
  <script src="vendor/typed.js/typed.min.js"></script>
  <script src="vendor/waypoints/noframework.waypoints.js"></script>
  <script src="vendor/php-email-form/validate.js"></script>

  <!-- Prism JS -->
  <script src="../cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>

  <!-- Template Main JS File -->
  <script src="js/main.js"></script>

  <script>
    let allOpen = false; // Track the state of the dropdowns

    function toggleIndex() {
      const index = document.getElementById('index');
      index.classList.toggle('open');
    }

    function toggleAll() {
      const dropdownContainers = document.querySelectorAll('.dropdown-container, .nested-dropdown-container');
      const buttons = document.querySelectorAll('.dropdown-btn, .nested-dropdown-btn');

      // Set the new state based on the current state
      allOpen = !allOpen;

      for (let i = 0; i < dropdownContainers.length; i++) {
        const container = dropdownContainers[i];
        const btn = buttons[i];
        if (allOpen) {
          container.style.display = 'block';
          btn.classList.add('active');
        } else {
          container.style.display = 'none';
          btn.classList.remove('active');
        }
      }
    }

    const dropdownBtns = document.getElementsByClassName("dropdown-btn");
    for (let i = 0; i < dropdownBtns.length; i++) {
      dropdownBtns[i].addEventListener("click", function () {
        this.classList.toggle("active");
        const dropdownContent = this.nextElementSibling;
        if (dropdownContent.style.display === "block") {
          dropdownContent.style.display = "none";
        } else {
          dropdownContent.style.display = "block";
        }
      });
    }

    const nestedDropdownBtns = document.getElementsByClassName("nested-dropdown-btn");
    for (let i = 0; i < nestedDropdownBtns.length; i++) {
      nestedDropdownBtns[i].addEventListener("click", function () {
        this.classList.toggle("active");
        const nestedDropdownContent = this.nextElementSibling;
        if (nestedDropdownContent.style.display === "block") {
          nestedDropdownContent.style.display = "none";
        } else {
          nestedDropdownContent.style.display = "block";
        }
      });
    }

    setTimeout(function() {
      var alert = document.querySelector('.alert-warning');
      if (alert) {
        var bootstrapAlert = new bootstrap.Alert(alert);
        bootstrapAlert.close();
      }
    }, 7000); // 7 seconds

    function removeHighlights(element) {
        element.innerHTML = element.innerHTML.replace(/<\/?strong>/gi, "");
      }

    function highlightTerm(element, term) {
      const regex = new RegExp(`(${term})`, 'gi');
      element.innerHTML = element.innerHTML.replace(regex, "<strong>$1</strong>");
    }

    document.getElementById("search-input").addEventListener("input", function () {
      const searchTerm = this.value.toLowerCase();
      const headings = document.querySelectorAll(".cheatsheet-content h2, .cheatsheet-content h3, .cheatsheet-content h4, .cheatsheet-content h5, .cheatsheet-content h6");
      let anyMatch = false;

      headings.forEach((heading) => {
        const text = heading.textContent.toLowerCase();
        const sectionContent = [];

        // Get all sibling elements until the next heading
        let sibling = heading.nextElementSibling;
        while (sibling && !sibling.matches("h2, h3, h4, h5, h6")) {
          sectionContent.push(sibling);
          sibling = sibling.nextElementSibling;
        }

        // Remove existing highlights
        removeHighlights(heading);

        // Only show headings and content that match the search term
        if (text.includes(searchTerm)) {
          heading.style.display = "";
          sectionContent.forEach((elem) => (elem.style.display = ""));
          if (searchTerm) {
            highlightTerm(heading, searchTerm);
          }

          anyMatch = true;
        } else {
          // Hide non-matching headings and content
          heading.style.display = "none";
          sectionContent.forEach((elem) => (elem.style.display = "none"));
        }
      });

      const noMatchMessage = document.getElementById("no-match-message");
      if (!anyMatch) {
        if (!noMatchMessage) {
          const message = document.createElement("p");
          message.id = "no-match-message";
          message.className = "text-danger mt-3";
          message.textContent = "No matches found.";
          document.querySelector(".cheatsheet-content").appendChild(message);
        }
      } else if (noMatchMessage) {
        noMatchMessage.remove();
      }
    });

    function toggleSubmenu(event) {
      event.preventDefault(); // Prevents navigation
      const submenu = event.currentTarget.nextElementSibling;
      const arrow = event.currentTarget.querySelector('.arrow');

      submenu.classList.toggle('open'); // Toggle the submenu visibility
      // Rotate the arrow based on whether the submenu is open
      if (submenu.classList.contains('open')) {
          arrow.style.transform = 'rotate(0deg)'; // Arrow points right when closed
      } else {
          arrow.style.transform = 'rotate(-90deg)';  // Arrow points down when open
      }
    }
  </script>

</body>

</html>